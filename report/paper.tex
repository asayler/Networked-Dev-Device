% Matthew Monaco
% Andy Sayler
% Landon Spear
% University of Colorado
% Networked Character devices
% Fall 2011

\documentclass[11pt,twocolumn]{article}

\usepackage[text={6.5in, 9in}, centering]{geometry}
\usepackage{graphicx}
\usepackage{url}
\usepackage{listings}

\bibliographystyle{plain}

\lstloadlanguages{C}
\lstset{
  language=C,
  basicstyle=\tiny,
  numbers=none,
  numberstyle=\footnotesize,
  stepnumber=1,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=4,
  captionpos=b,
  breaklines=true,
  breakatwhitespace=false,
  frame=none,
  frameround=tttt
}

\newenvironment{packed_enum}{
\begin{enumerate}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{enumerate}}

\newenvironment{packed_item}{
\begin{itemize}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{itemize}}

\begin{document}

\title{Networked Character Devices}
\author{Monaco, Matthew \and Sayler, Andrew \and Spear, Landon \\
  \and University of Colorado \\
  \texttt{first.last@colorado.edu}
}
\date{\today}

\maketitle

\begin{abstract}
While there are various projects which provide a network abstraction layer for
specific high-level subsystems in the Linux kernel, there aren't any low-level
general purpose solutions. Network character devices (NCD) is a system for
exporting character device interfaces over a network. This capability
divorces the traditional requirement that a device can only be used by
the host to which it is physically connected in favor of a model that
allows a device to be connected to one host but used by another.
In addition to networking the character device interface for which it
is optimized, NCD also works with regular files, block devices,
sockets, and pipes. We demonstrate how our NCD system works, as well
as a few examples of the unique systems that can be built atop the NCD
interface.
\end{abstract}

% Landon Sections

\section{Introduction}
\label{sec:introduction}

We did some stuff, we used some references \cite{ldd3}.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{system-full-g.png}
  \caption{The NCD system. See Figure \ref{fig:system-working}
    for currently implemented system state.}
  \label{fig:system-full}
\end{figure}

\section{Related Work}
\label{sec:relatedwork}

We are unique.

% Matt Sections

\section{Architecture}
\label{sec:architecture}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{arch-03-g.png}
  \caption{The basic client-server model of NCD.}
  \label{fig:architecture}
\end{figure}

On a very high level, NCD uses a basic client server model. The client
issues a request to the server, which in turn issues a reply. The
server never initiates any communication on its own.

\subsection{Client}

The client is currently implemented entirely within an out-of-tree kernel
module. This is arguably not the most robust, nor secure, solution. See
section \ref{sec:futurework} for details on splitting out some functionality
into a user-space helper.

Devices which have been imported on the client reside within the
devtmpfs filesystem. This is almost always mounted on \texttt{/dev}. By
default an imported device will take on the name
\texttt{/dev/netchar/importN}, where \texttt{N} is the next available
number. In the future (and without much effort), imported devices will
be able to take on their original name from the server. For example, an
input device should be located at \texttt{/dev/input/eventN}. Furthermore,
the user or administrator may choose any mapping (s)he see fits.

\subsection{Server}

The server is a typical user-space daemon. It
currently only services a single file. Whether or not the server should
handle multiple exports is still up for evaluation.

The server listens on a port specified on the command line. There is no
default. When a request is received from the client, it will correspond
to one of the standard VFS file operations. Currently, \texttt{open()},
\texttt{close()}
\footnote{The counterpart for \texttt{close()} is actually referred to
as \texttt{release()} within the kernel.}
, \texttt{read()}, and \texttt{write()} are supported.

After receiving a request, the server then performs the requested
operation locally and returns the result to the client in a reply
message. For example, if the client sends an \texttt{open()} request,
the server will open and hold a file descriptor on the client's behalf.

This straightforward architecture will actually support any file type
(with certain restrictions for each type). Character devices, regular
files, sockets, and pipes should work fully (when all file operations
are implemented). Block devices and even directories will work to some
extent.

\subsection{Protocol}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{proto-g.png}
  \caption{NCD operates over a simple request reply protocol. Bulk data
    immediately follows formal messages, as required.}
  \label{fig:protocol}
\end{figure}

The protocol is implemented as a simple request-reply system over
\texttt{INET} sockets. All request types are encapsulated within a
single request structure (see section \ref{sec:implementation}).
Similarly, there is only a single reply structure to account for all
reply types.

Bulk data is sent in the raw immediately following the corresponding
request/reply. In the case of a \texttt{read()}, the targeted data
immediately follows the reply. In the case of a \texttt{write()}, the
targeted data immediately follows the initial request.

\section{Implementation}
\label{sec:implementation}

\subsection{Protocol}

\lstinputlisting[
  caption={The structures which make up the NCD protocol.},
  label=lst:protocol
]{protocol.c}

The protocol for NCD operates over TCP sockets. Despite the potential
for large amounts of streaming data over the internet --- data which may
be acceptable to drop --- some messages are unacceptable to lose. Any
request or reply should be guaranteed. The data following a
\texttt{read()} or \texttt{write()} (figure \ref{fig:protocol}), for
example, may not be as important. Therefore, in the future it may be
beneficial to implement the core protocol over TCP and bulk data over
UDP (section \ref{sec:futurework}).

Because there is only one type of packet for a request, and another for
a reply, (listing \ref{lst:protocol}) there is a small amount of wasted
space on some file operations. We have done our best to reduce this
overhead as much as possible, making use of a cascade of nested unions
and structs.

The request struct is suitable to handle all of the function arguments
for all of the operations we support. The reply struct is much simpler
as functions only have a single return value. While some file operations
have output parameters and some userspace system calls do as well, there
aren't any cases where these need to be passed over the network.

\subsection{Client}

\lstinputlisting[
  caption={The NCD kernel module has a number of roles.},
  label=lst:client
]{cdev-driver.c}

The client resides entirely within a kernel module \footnote{The merits
of including everything within a kernel module are discussed in section
\ref{sec:currentstatus}.}. A typical userspace program can be sloppy
with cleanup because all memory is freed on termination. In contrast, a
kernel module must be very careful because its lifetime is shorter than
the kernel itself. Therefore it is very import to correctly handle
errors and cleanup all memory in the \texttt{module\_init} and
\texttt{module\_exit} routines.

Some of the basic features of the NCD kernel module are listed in
listing \ref{lst:client}. NCD dynamically requests a major and
minor number from the running kernel \footnote{Statically assigned
major/minor numbers are no longer required and are discouraged for new
modules.}. These numbers are stored in a \texttt{struct dev\_t}. Once
these numbers are assigned, the kernel will pass all file operations on
character devices with the NCD major/minor number to the NCD module.

The \texttt{struct class} is somewhat synonymous with a kernel
subsystem. Because the major/minor number is dynamic, it is with this
class that userspace is able to persistently refer to NCD character
device nodes (see \ref{subsec:udev}).

\texttt{Struct file\_operations} is used to define the handlers for all
file operations which we support for our character devices \footnote{See
\texttt{linux/fs.h} for a complete list of file operations.}.

Most importantly, \texttt{struct cdev} ties together the major/minor
number with the given set of file operations. With this it is possible
for a kernel module to register many major/minor numbers (typically
a contiguous range), while having fine-grained control over which
subsets are handled by which distinct groups of file operations. This
will be important in the future as specific subsystems are handled
differently by NCD to increase functionality.

Finally, \texttt{struct device} is used to actually create a character
device node under \texttt{/dev} in userspace. Unfortunately, not
everything we might want to do to this device can be accomplished in the
kernel (permissions for example).

\subsection{Server}

\lstinputlisting[
  caption={A code snippet from the server illustrating a \texttt{read()}
  file operation},
  label=lst:server
]{server.c}

The server will spend most of its time sitting on a blocked read of the
socket file descriptor. Once the client sends a request, it will be
available to the server in the appropriate structure.

In the snippet given in listing \ref{lst:server}, a \texttt{read()} file
operation is handled. A buffer must be allocated with a size
indicated by the original request. Next, the server can perform the
corresponding operation and send a reply message to the client. Finally,
the bulk data is sent to the client. All buffering is performed by the
underlying \texttt{SOCK\_STREAM} and TCP protocols.

The server itself is, and will always be, simple compared to the
in-kernel module. As NCD grows, the server's functionality should remain
fairly static. Section \ref{sec:futurework} discusses some enhancements
which will make the server more stable, however it doesn't require many
new features.

\subsection{Misc}

\subsubsection{udev}
\label{subsec:udev}

\lstinputlisting[
  lastline=1,
  caption={A simple \texttt{udev} rule for managing NCD device
  permissions.},
  label=lst:udevrule
]{udev.txt}

A lot of magic is performed on character devices in userspace by
the Linux \texttt{udev} system.
Currently we are using \texttt{udev} to manage the
permissions of imported devices (listing \ref{lst:udevrule}).

\lstinputlisting[
  firstline=3,
  caption={\texttt{udev} attributes required by userspace programs such
  as the \texttt{Xserver} for knowing a device is a keyboard.},
  label=lst:udevattr
]{udev.txt}

For more functionality, imported character devices must have certain
attributes such as those for the keyboard in listing \ref{lst:udevattr}.
Unfortunately setting them retroactively does not convince all programs
of a particular devices type. Therefore interfacing with specific kernel
subsystems such as \texttt{input} and \texttt{usb} will be required in
the future for enhanced functionality.

\subsubsection{ncadmin}

\lstinputlisting[
  language={},
  caption={The potential management interface for the NCD system.},
  label=lst:ncadmin
]{ncadmin.txt}

As NCD grows, it will be important for the client to be able to handle
dynamically added and removed devices. Listing \ref{lst:ncadmin}
provides an idea of what an interface would look like to provide such
functionality. This would give NCD the ability to create its character
devices anywhere under \texttt{/dev}; they could be placed in a similar
location to the corresponding device on the server.

% Andy Sections

\section{Results and Evaluation}
\label{sec:results}

The Network Character Devices system is still a work in
progress. We will need to expand the system beyond it's current state
before the NCD concept is ready for production-level use.

None the less, we have gained many insights into the advantages such a
system might provide. We have also encountered the difficulties
implementing such a system into an existing OS like Linux entails.

\subsection{Current Status}
\label{sec:currentstatus}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{system-working-g.png}
  \caption{The NCD system with currently functioning portions
    highlighted.}
  \label{fig:system-working}
\end{figure}

As of this writing, we have completed a partial implementation of
the Network Character Devices system. Current functionality includes:

\begin{packed_item}
\item Support for exporting a single character device from the server
\item Support for importing a single character device on the client
\item Support for \texttt{open()}, \texttt{close()}, \texttt{read()},
  and \texttt{write()} calls
\item Basic Linux \texttt{udev} support for automatic node
  provisioning on the client
\end{packed_item}

This set of core functionality provides a working proof-of-concept
Network Character Devices system. This system fully supports the
export of a single character device from server to client over the
network and demonstrates the basic use and utility of such a system.

It should be noted, however, that some work is still required before
the Network Character device system can be considered a production
ready utility. Most notably, the following features are necessary for
a fully functional NCD system, but are not yet included in our
implementation:

\begin{packed_item}
\item Multi-device, multi-server client-side import support
\item Multi-device server-side export support
\item Support for exclusive use and protection of exported devices
\item Support for ioctl calls
\item Support for providing and obtaining metadata for exported
  devices
\item Support for ``advertisement'' of available exported devices
\item Support for integrating imported devices into other kernel
  subsystems (human interface subsystem, audio subsystem, etc)
\item Addition of UDP and TCP support with user selection
\item Addition of graceful connect and disconnect handling in real-time
\end{packed_item}

Section \ref{sec:futurework} provides some insight into the addition
of some of these expanded features.

\subsection{Advantages}
\label{sec:advantages}



\subsection{Challenges}
\label{sec:challenges}

\section{Future Work}
\label{sec:futurework}

\section{Conclusion}
\label{sec:conclusion}

\nocite{*}
\bibliography{refs}

\end{document}

% vim: set ts=2 sts=2 sw=2 et spell tw=72 : %
