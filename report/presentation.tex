% presentation.tex
% Matthew Monaco
% Andy Sayler
% Landon Spear

\documentclass[xcolor=dvipsnames]{beamer}
\usetheme{AnnArbor}
\usecolortheme{beaver}
\setbeamercovered{transparent=25}
\setbeamertemplate{blocks}[rounded][shadow=false] 
\setbeamertemplate{navigation symbols}{}

\usepackage{graphicx}
\usepackage{url}
\usepackage{listings}

\bibliographystyle{plain}

\lstloadlanguages{C}
\lstset{
  language=C,
  basicstyle=\footnotesize,
  numbers=none,
  numberstyle=\footnotesize,
  stepnumber=1,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=4,
  captionpos=b,
  breaklines=true,
  breakatwhitespace=false,
  title=\lstname,
  frame=single,
  frameround=tttt
}

\newenvironment{packed_enum}{
\begin{enumerate}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{enumerate}}

\newenvironment{packed_item}{
\begin{itemize}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{itemize}}

\title[NCD]{Networked Character Devices}
%\subtitle[]{}
\author[Monaco, Sayler, Spear]{Matthew Monaco \&
                               Andrew Sayler \&
                               Landon Spear}
\institute[CU-Boulder]{
  University of Colorado at Boulder \\
  \texttt{\{first.last\}@colorado.edu}
}
\date[Dec. 10, 2011]{Saturday, December 10\textsuperscript{th}, 2011}

\begin{document}

%---Title Slide---%
\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}{Outline}
  \tableofcontents
\end{frame}

%Landon - Beginning

\section{Overview}
%---Intro Slide---%
\begin{frame}{\bf NCD Overview}
  We did some stuff, we used some references \cite{ldd3}.
\end{frame}

\section{Introduction}

\section{Related Work}

% Matt - Middle

% Combine Architecture and System?
\section{Architecture}

\begin{frame}[c]{Very High Level}
  \begin{center}
    \includegraphics[width=0.8\textwidth]{arch-01.png}
  \end{center}

  \begin{itemize}
    \item<1-> Our system uses a basic client server model
    \item<2-> The client initiates all exchanges, the server replies
  \end{itemize}
\end{frame}

\begin{frame}[c]{High Level}
  \begin{center}
    \includegraphics[width=0.8\textwidth]{arch-02.png}
  \end{center}

  \begin{itemize}
    \item<1-> The server side resides entirely in a single kernel module
    \item<2-> The client side is a standard userspace server
  \end{itemize}
\end{frame}

\begin{frame}[c]{Client Medium Level}
  \begin{center}
    \includegraphics[width=0.4\textwidth]{arch-03.png}
  \end{center}

  \begin{itemize}
    \item<1-> By default, devices are exposed under \texttt{/dev/netchar}
    \item<2-> In the future, we should be able to choose any name
  \end{itemize}
\end{frame}

\begin{frame}[c]{Server Medium Level}
  \begin{center}
    \includegraphics[width=0.8\textwidth]{arch-02.png}
  \end{center}
  \begin{itemize}
    \item<1-> Listen on a specified port
    \item<2-> Receive requests from client
    \begin{itemize}
      \item<2-> \texttt{open()},\texttt{close()},\texttt{read()},\texttt{write()},...
    \end{itemize}
    \item<3-> Can actually export \textit{any} file
    \item<4-> Crashes ungracefully when the client disconnects
  \end{itemize}
\end{frame}

\begin{frame}[c]{Protocol}
  \begin{center}
    \includegraphics[width=0.8\textwidth]{proto.png}
  \end{center}

  \begin{itemize}
    \item<1-> Structures passed through \texttt{INET} socket
    \item<2-> Raw data immediately follows when necessary
    \begin{itemize}
      \item<2-> \texttt{read()}, \texttt{write()}, ...
    \end{itemize}
  \end{itemize}
\end{frame}


\section{Implementation}

\subsection{Protocol}

\begin{frame}[fragile]{Protocol}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{lstlisting}[gobble=8]
        enum FOPS {
          FOP_OPEN, FOP_RELEASE,
          FOP_READ, FOP_WRITE,
          _FOP_ERROR
        };

        struct fop_request {

          enum FOPS call;

          union {
            struct {
              int     flags;
              mode_t  mode;
            };

            size_t  count;
          };
        };
      \end{lstlisting}
    \end{column}
    \begin{column}{0.5\textwidth}
      \begin{lstlisting}[gobble=8]
        struct fop_reply {

          enum FOPS call;

          union {
            int      open;
            int      close;
            ssize_t  read;
            ssize_t  write;
          };
        };
      \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Client}

\begin{frame}[fragile]{Hello, World!}
  \begin{columns}
    \begin{column}{0.6\textwidth}
      \begin{lstlisting}[gobble=8]
        #include <linux/kernel.h>
        #include <linux/module.h>

        static int __init nc_init(void)
        {
          /* do stuff */
          return 0;
        }

        static int __exit nc_exit(void)
        {
          /* undo stuff */
        }

        MODULE_LICENSE("GPL");

        module_init(nc_init);
        module_exit(nc_exit);

      \end{lstlisting}
    \end{column}
    \begin{column}{0.4\textwidth}
      \begin{itemize}
        \item initial setup
        \item cleanup important!
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Character Device Driver}
  \begin{lstlisting}[gobble=4]
    #include <linux/cdev.h>
    #include <linux/device.h>
    #include <linux/fs.h>

    static dev_t          nc_dev_t;
    static struct class*  nc_class;
    static struct cdev*   nc_cdev;
    static struct device* nc_device;

  \end{lstlisting}

  \begin{itemize}
    \item<1-> \texttt{dev\_t}: major/minor number
    \item<2-> \texttt{class}: subsystem
    \item<3-> \texttt{cdev}: handler for character devices
    \item<4-> \texttt{device}: userspace \texttt{/dev} node
    \item<5-> each has some form of registration mechanism
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Filesystem Handler}
  \begin{lstlisting}[gobble=4]
    #include <linux/fs.h>

    static int netchar_open(struct inode* inp, struct file* fp);
    static ssize_t netchar_read(struct file* fp, char* buffer,
                                size_t length, loff_t* offset);

    static struct file_operations nc_fops = {
      /* ... */
      .open  = nc_open,
      .read  = nc_read,
    }
  \end{lstlisting}

  \begin{itemize}
    \item<1-> required when registering character device
    \item<2-> buffer is a userspace pointer!
    \item<3-> event driven, blocking, asynchronous
  \end{itemize}
\end{frame}

\begin{frame}{Socket Client}
  \begin{itemize}
    \item<1-> socket type: \texttt{AF\_INET}, \texttt{SOCK\_STREAM}, \texttt{IPPROTO\_TCP}
    \begin{itemize}
      \item<2-> should be \texttt{AF\_NETLINK}
      \item<2-> do not want to lose messages
    \end{itemize}
    \item<3-> no familiar \texttt{read()}, \texttt{write()}
  \end{itemize}
\end{frame}

\subsection{Server}

\begin{frame}[fragile]{Server (\texttt{read()})}
  \begin{lstlisting}[gobble=4]
    struct fop_request req;
    struct fop_reply   rep;
    while (1) {
      err = read(sd, &req, sizeof(req));
      switch(req.call) {
      case FOP_READ:
        payload = realloc(payload, req.count);
        rep.read = read(fd, payload, req.count);
        if (rep.read < 0)
          rep.read = -errno;
        break;
      }
      err = write(sd, &rep, sizeof(rep));
      if (rep.call == FOP_READ && rep.read > 0)
        err = write(sd, payload, rep.read)
    }
  \end{lstlisting}
\end{frame}

\subsection{Misc}

\begin{frame}{\texttt{udev}}
\end{frame}

\begin{frame}{\texttt{ncadmin}}
\end{frame}

% Matt - End

% Andy Sections

\section{Results and Evaluation}
%---Full State Slide---%

\begin{frame}[c]{Full System}
  \begin{center}
    \includegraphics[height=0.75\paperheight,keepaspectratio]{system-full.png}
  \end{center}
\end{frame}

%---Current State Image Slide---%
\begin{frame}[c]{Current State}
  \begin{center}
    \includegraphics[height=0.75\paperheight,keepaspectratio]{system-working.png}
  \end{center}
\end{frame}

%---Current State Slide---%
\begin{frame}{\bf Current State}

\begin{itemize}
\item Supports exporting a single character device from the server
\item Supports importing a single character device on the client
\item Supports open, close, read, and write calls
\item Supports basic Linux udev operation for automatic node
  creation on client
\item Tested with various ``real'' and device files
\end{itemize}

\end{frame}

%---ToDo Slide---%
\begin{frame}{\bf ToDo}

\begin{itemize}
\item Multi-device, multi-server client-side import support
\item Multi-device server-side export support
\item Support for exclusive use and protection of exported devices
\item Support for ioctl calls
\item Support for providing and obtaining metadata for exported
  devices
\item Support for ``advertisement'' of available exported devices
\item Support for integrating imported devices into other kernel
  subsystems (human interface subsystem, audio subsystem, etc)
\item Addition of ``NCD-admin'' utilities for managing and administering
  NCD system
\item Addition of graceful connect and disconnect handling in real-time
\end{itemize}

\end{frame}

%---Advantages Slide---%
\begin{frame}{\bf Advantages}

What are the benefits of using Networked Character Device?

\begin{itemize}
\item Divorces peripherals from the computers to which they are
  attached
\item Allows simple creation of a ``Device Server''
\item Extends the ``Everything Is A File'' -nix Philosophy
\item Allows more efficient use of devices
\item Allows devices to be networked in a generalized, uniform manner
\end{itemize}

\end{frame}

%---Challenges Slide---%
\begin{frame}{\bf Challenges}

But there are difficulties making it work on a production scale...

\begin{itemize}
\item Does not work well when Character Device is not the exclusive
  device interface
  \begin{itemize}
  \item Many modern day devices interface directly with other
    in-kernel function, interfaces, and APIs
  \item procfs and sysfs provide additional device interface points
  \item Socket interfaces (netlink, etc) provide alternative to file
    system interfaces
  \end{itemize}
\item Requires exported devices to be ``de-integrated'' from host system
\item Requires QOS guarantees and high guilty network connection
\end{itemize}

\end{frame}

%---Potential Uses Slide---%
\begin{frame}{\bf Potential Uses}

What can we use NCDs for?

\begin{itemize}
\item Quick, cheap, and simple ad-hoc network KVM systems
\item Remote, networked web-cams, scanners, printers, etc
\item Basis of ``protocol''-over-Ethernet systems (USB-over-Ethernet,
  SATA-over-Ethernet, Etc)
\item Basis of redundant, ``cloud-like'' device pools
\item Basis of peripheral cluster systems (GPU Clusters, RNG Clusters,
  Etc)
\end{itemize}

\end{frame}


\section{Future Work}
%---Potential Uses Slide---%
\begin{frame}{\bf Future Work}

\begin{itemize}
\item Add multi-device, multi-server support
\item Add kernel sub-system handler layer (HID, etc)
\item Add device protection and removal capabilities to server system
\item Add advertisement protocol
\item Consider removing networking code from client kernel module
\end{itemize}

\end{frame}

\section{Conclusion}

\section{Bibliography}
%---Bibliography---%
\begin{frame}{\bf Bibliography}

\bibliography{refs}

\end{frame}

\end{document}

% vim: set sw=2 ts=2 sts=2 et spell : %
